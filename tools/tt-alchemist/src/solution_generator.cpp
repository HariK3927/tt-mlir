// SPDX-FileCopyrightText: (c) 2025 Tenstorrent AI ULC
//
// SPDX-License-Identifier: Apache-2.0

#include "include/solution_generator.h"
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

namespace fs = std::filesystem;

namespace tt_alchemist {

SolutionGenerator::SolutionGenerator() {}

bool SolutionGenerator::generateSolution(const std::string &cpp_file,
                                         const std::string &output_dir) {
  // Create the directory structure
  if (!createDirectoryStructure(output_dir)) {
    return false;
  }

  // Copy the C++ code to the solution
  if (!copyCppCode(cpp_file, output_dir)) {
    return false;
  }

  // Generate the CMakeLists.txt file
  if (!generateCMakeLists(output_dir)) {
    return false;
  }

  // Generate the build scripts
  if (!generateBuildScripts(output_dir)) {
    return false;
  }

  // Generate the README.md file
  if (!generateReadme(output_dir)) {
    return false;
  }

  return true;
}

bool SolutionGenerator::createDirectoryStructure(
    const std::string &output_dir) {
  try {
    // Create the main directory
    fs::create_directories(output_dir);

    // Create the src directory
    fs::create_directories(output_dir + "/src");

    // Create the include directory
    fs::create_directories(output_dir + "/include");

    // Create the build_configs directory
    fs::create_directories(output_dir + "/build_configs");

    // Create the scripts directory
    fs::create_directories(output_dir + "/scripts");

    return true;
  } catch (const std::exception &e) {
    last_error_ =
        "Failed to create directory structure: " + std::string(e.what());
    return false;
  }
}

bool SolutionGenerator::copyCppCode(const std::string &cpp_file,
                                    const std::string &output_dir) {
  try {
    // Copy the C++ file to the src directory
    fs::copy_file(cpp_file, output_dir + "/src/model_implementation.cpp",
                  fs::copy_options::overwrite_existing);

    // Create a simple header file
    std::ofstream header_file(output_dir + "/include/model_interface.h");
    if (!header_file) {
      last_error_ = "Failed to create header file";
      return false;
    }

    header_file << "#ifndef MODEL_INTERFACE_H\n";
    header_file << "#define MODEL_INTERFACE_H\n\n";
    header_file << "// Generated by tt-alchemist\n\n";
    header_file << "extern \"C\" {\n";
    header_file << "    void run_model(const float* input, float* output);\n";
    header_file << "}\n\n";
    header_file << "#endif // MODEL_INTERFACE_H\n";

    header_file.close();

    return true;
  } catch (const std::exception &e) {
    last_error_ = "Failed to copy C++ code: " + std::string(e.what());
    return false;
  }
}

bool SolutionGenerator::generateCMakeLists(const std::string &output_dir) {
  // Create the main CMakeLists.txt file
  std::map<std::string, std::string> replacements;
  replacements["@PROJECT_NAME@"] = fs::path(output_dir).filename().string();

  return processTemplate("templates/project/CMakeLists.txt.in",
                         output_dir + "/CMakeLists.txt", replacements);
}

bool SolutionGenerator::generateBuildScripts(const std::string &output_dir) {
  // Create the build scripts
  std::map<std::string, std::string> replacements;
  replacements["@PROJECT_NAME@"] = fs::path(output_dir).filename().string();

  // Create the build script
  if (!processTemplate("templates/run_scripts/run.sh.in",
                       output_dir + "/scripts/run.sh", replacements)) {
    return false;
  }

  // Create the profile script
  if (!processTemplate("templates/run_scripts/profile.sh.in",
                       output_dir + "/scripts/profile.sh", replacements)) {
    return false;
  }

  // Make the scripts executable
  std::system(("chmod +x " + output_dir + "/scripts/run.sh").c_str());
  std::system(("chmod +x " + output_dir + "/scripts/profile.sh").c_str());

  return true;
}

bool SolutionGenerator::generateReadme(const std::string &output_dir) {
  // Create the README.md file
  std::map<std::string, std::string> replacements;
  replacements["@PROJECT_NAME@"] = fs::path(output_dir).filename().string();

  return processTemplate("templates/project/README.md.in",
                         output_dir + "/README.md", replacements);
}

bool SolutionGenerator::processTemplate(
    const std::string &template_file, const std::string &output_file,
    const std::map<std::string, std::string> &replacements) {
  try {
    // For now, we'll just create simple files with placeholders
    // In a real implementation, we would read the template file and replace the
    // placeholders

    std::ofstream file(output_file);
    if (!file) {
      last_error_ = "Failed to create file: " + output_file;
      return false;
    }

    if (template_file.find("CMakeLists.txt.in") != std::string::npos) {
      file << "cmake_minimum_required(VERSION 3.16)\n";
      file << "project(" << replacements.at("@PROJECT_NAME@") << " CXX)\n\n";
      file << "set(CMAKE_CXX_STANDARD 17)\n";
      file << "set(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n";
      file << "# Add the source files\n";
      file << "add_executable(" << replacements.at("@PROJECT_NAME@")
           << " src/model_implementation.cpp)\n\n";
      file << "# Include directories\n";
      file << "target_include_directories(" << replacements.at("@PROJECT_NAME@")
           << " PRIVATE include)\n\n";
      file << "# Link against required libraries\n";
      file << "target_link_libraries(" << replacements.at("@PROJECT_NAME@")
           << " PRIVATE)\n";
    } else if (template_file.find("README.md.in") != std::string::npos) {
      file << "# " << replacements.at("@PROJECT_NAME@") << "\n\n";
      file << "This is a generated solution for "
           << replacements.at("@PROJECT_NAME@") << ".\n\n";
      file << "## Building\n\n";
      file << "```bash\n";
      file << "mkdir -p build && cd build\n";
      file << "cmake ..\n";
      file << "make\n";
      file << "```\n\n";
      file << "## Running\n\n";
      file << "```bash\n";
      file << "./scripts/run.sh\n";
      file << "```\n\n";
      file << "## Profiling\n\n";
      file << "```bash\n";
      file << "./scripts/profile.sh\n";
      file << "```\n";
    } else if (template_file.find("run.sh.in") != std::string::npos) {
      file << "#!/bin/bash\n\n";
      file << "# Run script for " << replacements.at("@PROJECT_NAME@")
           << "\n\n";
      file << "# Build the solution\n";
      file << "mkdir -p build && cd build\n";
      file << "cmake ..\n";
      file << "make\n\n";
      file << "# Run the solution\n";
      file << "./" << replacements.at("@PROJECT_NAME@") << "\n";
    } else if (template_file.find("profile.sh.in") != std::string::npos) {
      file << "#!/bin/bash\n\n";
      file << "# Profile script for " << replacements.at("@PROJECT_NAME@")
           << "\n\n";
      file << "# Build the solution with profiling enabled\n";
      file << "mkdir -p build_profile && cd build_profile\n";
      file << "cmake .. -DCMAKE_BUILD_TYPE=Profile\n";
      file << "make\n\n";
      file << "# Run the solution with profiling\n";
      file << "./" << replacements.at("@PROJECT_NAME@") << "\n";
    }

    file.close();

    return true;
  } catch (const std::exception &e) {
    last_error_ = "Failed to process template: " + std::string(e.what());
    return false;
  }
}

std::string SolutionGenerator::getLastError() const { return last_error_; }

} // namespace tt_alchemist
