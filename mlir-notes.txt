Operation/Region/Block

1. Operations (Ops):
The core unit of computation in MLIR.
Each operation can represent a simple instruction (e.g., addition) or a complex construct (e.g., loops or function calls).
Operations have a name, operands, results, attributes, and can contain nested regions.

2. Regions:
A region is a container for a sequence of basic blocks.
Some operations (like functions, loops, or conditionals) may have one or more regions inside them.
A region does not have arguments, only the blocks inside it do.

3. Blocks:
A block is a sequence of operations with a single-entry point.
Blocks contain operations and define control flow within a region.
A block has:
A list of operations.
A list of arguments (used for control flow, similar to SSA phi nodes).
A single successor per entry.

Value/Type/Attribute

1. Values
A value represents a runtime entity produced and consumed by operations.
It can be:
An SSA (Static Single Assignment) value, which is the output of an operation.
A block argument, which represents an input to a block.
Each value is typed, meaning it has an associated type.

2. Types
A type in MLIR describes what kind of data a value holds.
Types in MLIR are extensible and can be scalars, tensors, vectors, etc.
Examples of types:
Primitive types: i32, f64
Composite types: tensor<4xf32>, memref<10xi8>, vector<8xi16>

3. Attributes
An attribute is constant metadata attached to an operation.
Unlike values, attributes are immutable and do not represent runtime data.
Attributes are used for things like:
Literal constants (DenseElementsAttr, IntegerAttr, FloatAttr)
Compiler hints (StringAttr, ArrayAttr)

Attributes/Properties/Traits of Operations

1. Attributes
Immutable, constant metadata attached to an operation.
Used to store compile-time known values, such as:
Integer/floating-point literals (IntegerAttr, FloatAttr)
String metadata (StringAttr)
Lists (ArrayAttr, DenseElementsAttr)
Attributes must be explicitly specified in the operation definition.

2. Properties
Structured, strongly-typed metadata stored inside operations.
More flexible than attributes, as they allow richer types and can support dynamic behaviors.
Unlike attributes, properties are not stored in the operation dictionary but are defined in operation C++ classes.

3. Traits
Code-gen helpers that specify generic properties of an operation.
Unlike attributes and properties, traits do not store values but enforce constraints and behaviors.
MLIR provides built-in traits, such as:
ZeroOperands → Ensures the operation has no operands.
IsTerminator → Marks the operation as a terminator (like return).
SameOperandsAndResultType → Ensures all operands and results have the same type.

Builder

1. mlir::Builder
Purpose: mlir::Builder is a utility class designed to help with constructing MLIR operations and types. It provides a simpler, higher-level interface to create operations (ops), attributes, and types. It also ensures that the generated operations are properly inserted into the correct locations in the IR.
Use Case: Use this when you're writing code that directly generates MLIR operations and you need a straightforward way to build and insert ops into a block.
Typical use:
mlir::Builder builder(context);
builder.create<mlir::AddOp>(loc, operand1, operand2);

2. mlir::OpBuilder
Purpose: mlir::OpBuilder is a specialized version of mlir::Builder that focuses on building and inserting MLIR operations into a function or region. It also keeps track of the current insertion point in the IR, so you can control where new operations will be inserted.
Use Case: Use mlir::OpBuilder when working with specific regions or functions in the IR, and you need to manage the insertion point dynamically as you generate code.
Typical use:
mlir::OpBuilder builder(context);
builder.setInsertionPointToStart(&block);
builder.create<mlir::AddOp>(loc, operand1, operand2);



{
mlir::Identifier
- static Identifier 	get (StringRef str, MLIRContext *context)
- StringRef 	strref () const
- std::string 	str () const
- const char * 	c_str () const
- const char * 	data () const
- unsigned 	size () const
- bool 	is (StringRef string) const
}

/*
Types
*/

mlir::Type
- mlir::BFloat16Type
- mlir::Float16Type
- mlir::Float32Type
- mlir::Float64Type
- mlir::Float80Type
- mlir::Float128Type
- mlir::FloatTF32Type
- mlir::IntegerType
- mlir::RankedTensorType
- mlir::ShapedType

{
mlir::Type
- TypeID 	getTypeID ()
- MLIRContext * 	getContext () const
- Dialect & 	getDialect () const
- bool 	isBF16 () const
- bool 	isF16 () const
- bool 	isTF32 () const
- bool 	isF32 () const
- bool 	isF64 () const
- bool 	isF80 () const
- bool 	isF128 () const
- bool 	isFloat () const
- bool 	isInteger () const
- bool 	isSignlessInteger () const
- bool 	isSignedInteger () const
- bool 	isUnsignedInteger () const
- void 	print (raw_ostream &os) const

template<typename... Tys>
- bool 	isa () const

template<typename U >
- U 	dyn_cast () const

template<typename U >
- U 	dyn_cast_or_null () const

template<typename U >
- U 	cast () const
}

{
mlir::BFloat16Type
mlir::Float16Type
mlir::Float16Type
mlir::Float32Type
mlir::Float64Type
mlir::Float80Type
mlir::Float128Type
mlir::FloatTF32Type
- BFloat16Type BFloat16Type::get(MLIRContext *)
}

{
mlir::IntegerType
- IntegerType IntegerType::get(MLIRContext *, unsigned, IntegerType::SignednessSemantics)
- unsigned getWidth()
- SignednessSemantics getSignedness()
}

{
mlir::ShapedType
class ShapedType : public Type
- Type getElementType() const;
- int64_t getNumElements() const;
- int64_t getRank() const;
- bool hasRank() const;
- ArrayRef<int64_t> getShape() const;

class TensorType : public ShapedType
class RankedTensorType : public Type::TypeBase<RankedTensorType, TensorType, detail::RankedTensorTypeStorage>
class UnrankedTensorType : public Type::TypeBase<UnrankedTensorType, TensorType, detail::UnrankedTensorTypeStorage>
}

{
mlir::RankedTensorType
- RankedTensorType RankedTensorType::get(MLIRContext *, ::llvm::ArrayRef<int64_t>, Type)
- RankedTensorType RankedTensorType::get(MLIRContext *, ::llvm::ArrayRef<int64_t>, Type, Attribute)
}

/*
Attributes
*/

mlir::Attribute
- StringAttr
- DictionaryAttr
- DenseElementsAttr
- ArrayAttr
- DenseArrayAttr
  - DenseI8ArrayAttr
  - DenseI16ArrayAttr
  - DenseI32ArrayAttr
  - DenseI64ArrayAttr
  - DenseF32ArrayAttr
  - DenseF64ArrayAttr
- LocationAttr
  - mlir::CallSiteLoc
  - mlir::FileLineColLoc
  - mlir::FusedLoc
  - mlir::NameLoc
  - mlir::UnknownLoc

{
mlir::Attribute
- TypeID 	getTypeID ()
- MLIRContext * 	getContext () const
- Dialect & 	getDialect () const
- void 	print (raw_ostream &os) const

template<typename... Tys>
- bool 	isa () const

template<typename U >
- U 	dyn_cast () const

template<typename U >
- U 	dyn_cast_or_null () const

template<typename U >
- U 	cast () const
}

{
mlir::CallSiteLoc
- static Location 	get (Location callee, Location caller)
- Location 	getCallee () const
- Location 	getCaller () const
}

{
mlir::FileLineColLoc
- static Location 	get (Identifier filename, unsigned line, unsigned column, MLIRContext *context)
- static Location 	get (StringRef filename, unsigned line, unsigned column, MLIRContext *context)
- StringRef 	getFilename () const
- unsigned 	getLine () const
- unsigned 	getColumn () const
}

{
mlir::FusedLoc
- static Location 	get (ArrayRef< Location > locs, Attribute metadata, MLIRContext *context)
- static Location 	get (ArrayRef< Location > locs, MLIRContext *context)
- ArrayRef< Location > 	getLocations () const
- Attribute 	getMetadata () const
}

{
mlir::NameLoc
- static Location 	get (Identifier name, Location child)
- static Location 	get (Identifier name, MLIRContext *context)
- Identifier 	getName () const
Location 	getChildLoc () const
}

{
mlir::UnknownLoc
- static Location 	get (MLIRContext *context)
}

{
mlir::NamedAttribute
NamedAttribute (StringAttr name, Attribute value)
- StringAttr 	getName () const
- Attribute 	getValue () const
- void 	setName (StringAttr newName)
- void 	setValue (Attribute newValue)
}

{
DictionaryAttr
- static DictionaryAttr::get(MLIRContext *context, ArrayRef<NamedAttribute> value)
- ArrayRef< NamedAttribute > 	getValue () const
- Attribute get(StringRef name) const
- bool empty() const
- size_t size () const
- iterator 	begin () const
- iterator 	end () const
}

{
DenseElementsAttr
- static DenseElementsAttr get(ShapedType type, ArrayRef< Attribute > values)
- static DenseElementsAttr 	get(ShapedType type, ArrayRef< bool > values)

template<typename T , typename = typename std::enable_if< std::numeric_limits<T>::is_integer || llvm::is_one_of<T, float, double>::value>::type>
- static DenseElementsAttr get(const ShapedType &type, ArrayRef< T > values)

template<typename T , typename = typename std::enable_if< std::numeric_limits<T>::is_integer || llvm::is_one_of<T, float, double>::value>::type>
- static DenseElementsAttr get(const ShapedType &type, T value)
}

/*
Value
*/

mlir::Value
- mlir::BlockArgument
- mlir::OpResult
- mlir::detail::TypedValue<Ty>

{
mlir::Value
- Type 	getType () const
- MLIRContext * 	getContext () const
- void 	setType (Type newType)
- Operation * 	getDefiningOp () const
- Location 	getLoc () const
- void 	setLoc (Location loc)
- void 	replaceAllUsesWith (Value newValue)
- bool 	use_empty () const
- bool 	hasOneUse () const
- user_range 	getUsers () const
}

{
mlir::BlockArgument
- unsigned 	getArgNumber () const
- Location 	getLoc () const
- void 	setLoc (Location loc)
}

{
mlir::OpResult
- Operation * 	getOwner () const
- unsigned 	getResultNumber () const
}

{
mlir::detail::TypedValue<Ty>
- Ty 	getType () const
- void 	setType (Ty ty)
}

/*
mlir::Location
*/

{
mlir::Location
- Location (LocationAttr loc)
- MLIRContext * 	getContext () const
- LocationAttr * 	operator-> () const
}

/*
Builder
*/

mlir::Builder
- mlir::OpBuilder
  - mlir::RewriterBase
    - mlir::IRRewriter
    - mlir::PatternRewriter
      - mlir::ConversionPatternRewriter
    - mlir::transform::TransformRewriter

{
mlir::Builder
- mlir::Builder (MLIRContext *context)
- MLIRContext * getContext () const
- Location 	getUnknownLoc ()
- FloatType 	getBF16Type ()
- FloatType 	getF16Type ()
- FloatType 	getTF32Type ()
- FloatType 	getF32Type ()
- FloatType 	getF64Type ()
- FloatType 	getF80Type ()
- FloatType 	getF128Type ()
- IntegerType 	getI1Type ()
- IntegerType 	getI2Type ()
- IntegerType 	getI4Type ()
- IntegerType 	getI8Type ()
- IntegerType 	getI16Type ()
- IntegerType 	getI32Type ()
- IntegerType 	getI64Type ()

- BoolAttr 	getBoolAttr (bool value)
- DictionaryAttr 	getDictionaryAttr (ArrayRef< NamedAttribute > value)
- IntegerAttr 	getIntegerAttr (Type type, int64_t value)
- IntegerAttr 	getIntegerAttr (Type type, const APInt &value)
- FloatAttr 	getFloatAttr (Type type, double value)
- FloatAttr 	getFloatAttr (Type type, const APFloat &value)
- StringAttr 	getStringAttr (const Twine &bytes)
- ArrayAttr 	getArrayAttr (ArrayRef< Attribute > value)
- TypedAttr 	getZeroAttr (Type type)
- TypedAttr 	getOneAttr (Type type)
- FloatAttr 	getF16FloatAttr (float value)
- FloatAttr 	getF32FloatAttr (float value)
- FloatAttr 	getF64FloatAttr (double value)
- IntegerAttr 	getI8IntegerAttr (int8_t value)
- IntegerAttr 	getI16IntegerAttr (int16_t value)
- IntegerAttr 	getI32IntegerAttr (int32_t value)
- IntegerAttr 	getI64IntegerAttr (int64_t value)
- IntegerAttr 	getSI32IntegerAttr (int32_t value)
- IntegerAttr 	getUI32IntegerAttr (uint32_t value)
- DenseIntElementsAttr 	getBoolVectorAttr (ArrayRef< bool > values)
- DenseIntElementsAttr 	getI32VectorAttr (ArrayRef< int32_t > values)
- DenseIntElementsAttr 	getI64VectorAttr (ArrayRef< int64_t > values)
- DenseFPElementsAttr 	getF32VectorAttr (ArrayRef< float > values)
- DenseFPElementsAttr 	getF64VectorAttr (ArrayRef< double > values)
- DenseIntElementsAttr 	getI32TensorAttr (ArrayRef< int32_t > values)
- DenseIntElementsAttr 	getI64TensorAttr (ArrayRef< int64_t > values)
- DenseBoolArrayAttr 	getDenseBoolArrayAttr (ArrayRef< bool > values)
- DenseI8ArrayAttr 	getDenseI8ArrayAttr (ArrayRef< int8_t > values)
- DenseI16ArrayAttr 	getDenseI16ArrayAttr (ArrayRef< int16_t > values)
- DenseI32ArrayAttr 	getDenseI32ArrayAttr (ArrayRef< int32_t > values)
- DenseI64ArrayAttr 	getDenseI64ArrayAttr (ArrayRef< int64_t > values)
- DenseF32ArrayAttr 	getDenseF32ArrayAttr (ArrayRef< float > values)
- DenseF64ArrayAttr 	getDenseF64ArrayAttr (ArrayRef< double > values)
- ArrayAttr 	getAffineMapArrayAttr (ArrayRef< AffineMap > values)
- ArrayAttr 	getBoolArrayAttr (ArrayRef< bool > values)
- ArrayAttr 	getI32ArrayAttr (ArrayRef< int32_t > values)
- ArrayAttr 	getI64ArrayAttr (ArrayRef< int64_t > values)
- ArrayAttr 	getIndexArrayAttr (ArrayRef< int64_t > values)
- ArrayAttr 	getF32ArrayAttr (ArrayRef< float > values)
- ArrayAttr 	getF64ArrayAttr (ArrayRef< double > values)
- ArrayAttr 	getStrArrayAttr (ArrayRef< StringRef > values)
- ArrayAttr 	getTypeArrayAttr (TypeRange values)
- NamedAttribute 	getNamedAttr (StringRef name, Attribute val)

template<typename Ty , typename... Args>
- Ty 	getType (Args &&...args)

template<typename Attr , typename... Args>
- Attr 	getAttr (Args &&...args)
}

{
mlir::OpBuilder
- OpBuilder (MLIRContext *ctx)
- void 	clearInsertionPoint ()
- void 	setInsertionPoint (Block *block, Block::iterator insertPoint)
- void 	setInsertionPoint (Operation *op)
- Operation * 	clone (Operation &op, IRMapping &mapper)
- Operation * 	clone (Operation &op)

template<typename OpTy , typename... Args>
- OpTy 	create (Location location, Args &&...args)
}

/*
mlir::Operation
*/

{
mlir::OperationState
- OperationState (Location location, StringRef name)
- OperationState (Location location, OperationName name)
- OperationState (Location location, OperationName name, ValueRange operands, TypeRange types, ArrayRef< NamedAttribute > attributes={}, BlockRange successors={}, MutableArrayRef< std::unique_ptr< Region >> regions={})
- OperationState (Location location, StringRef name, ValueRange operands, TypeRange types, ArrayRef< NamedAttribute > attributes={}, BlockRange successors={}, MutableArrayRef< std::unique_ptr< Region >> regions={})
- void 	addOperands (ValueRange newOperands)
- void 	addTypes (ArrayRef< Type > newTypes)
- void 	addAttribute (StringRef name, Attribute attr)
- void 	addAttribute (StringAttr name, Attribute attr)
- void 	addAttributes (ArrayRef< NamedAttribute > newAttributes)
- MLIRContext * 	getContext () const
}

{
mlir::OperationName
- OperationName (StringRef name, MLIRContext *context)
- StringRef 	getStringRef () const
- StringAttr 	getIdentifier () const
- MLIRContext * 	getContext ()
}

{
mlir::OpOperand
- unsigned 	getOperandNumber ()
- void 	assign (Value value)
}

{
mlir::OpResult
- Operation * 	getOwner () const
- unsigned 	getResultNumber () const
}

{
mlir::Operation
- static Operation * 	create (Location location, OperationName name, TypeRange resultTypes, ValueRange operands, NamedAttrList &&attributes, OpaqueProperties properties, BlockRange successors, unsigned numRegions)
- static Operation * 	create (Location location, OperationName name, TypeRange resultTypes, ValueRange operands, DictionaryAttr attributes, OpaqueProperties properties, BlockRange successors, unsigned numRegions)
- static Operation * 	create (const OperationState &state)
- static Operation * 	create (Location location, OperationName name, TypeRange resultTypes, ValueRange operands, NamedAttrList &&attributes, OpaqueProperties properties, BlockRange successors={}, RegionRange regions={})

OperationName 	getName ()
void 	erase ()
void 	remove ()
Operation * 	clone (IRMapping &mapper, CloneOptions options=CloneOptions::all())
Operation * 	clone (CloneOptions options=CloneOptions::all())
Block * 	getBlock ()
MLIRContext * 	getContext ()
Dialect * 	getDialect ()
Location 	getLoc ()
void 	setLoc (Location loc)
Region * 	getParentRegion ()
bool 	isProperAncestor (Operation *other)
bool 	isAncestor (Operation *other)
void 	replaceUsesOfWith (Value from, Value to)
void 	replaceAllUsesWith (ValuesT &&values)
void 	dropAllReferences ()
void 	moveBefore (Operation *existingOp)
void 	moveAfter (Operation *existingOp)

void 	setOperands (ValueRange operands)
unsigned 	getNumOperands ()
Value 	getOperand (unsigned idx)
void 	setOperand (unsigned idx, Value value)
void 	eraseOperand (unsigned idx)
operand_iterator 	operand_begin ()
operand_iterator 	operand_end ()
operand_range 	getOperands ()
MutableArrayRef< OpOperand > 	getOpOperands ()
OpOperand & 	getOpOperand (unsigned idx)
operand_type_range 	getOperandTypes ()

unsigned 	getNumResults ()
OpResult 	getResult (unsigned idx)
result_range 	getResults ()
result_range 	getOpResults ()
OpResult 	getOpResult (unsigned idx)

ArrayRef< NamedAttribute > 	getAttrs ()
DictionaryAttr 	getAttrDictionary ()
void 	setAttrs (DictionaryAttr newAttrs)
void 	setAttrs (ArrayRef< NamedAttribute > newAttrs)
Attribute 	getAttr (StringAttr name)
bool 	hasAttr (StringAttr name)
void 	setAttr (StringAttr name, Attribute value)
void 	setAttr (StringRef name, Attribute value)
Attribute 	removeAttr (StringAttr name)
Attribute 	removeAttr (StringRef name)

LogicalResult 	fold (ArrayRef< Attribute > operands, SmallVectorImpl< OpFoldResult > &results)
LogicalResult 	fold (SmallVectorImpl< OpFoldResult > &results)

void 	dropAllUses ()
use_range 	getUses ()
bool 	hasOneUse ()
bool 	use_empty ()
user_range 	getUsers ()
}

{
mlir::ModuleOp (has a single region and a single block)
- static ModuleOp 	create (Location loc, Optional< StringRef > name=llvm::None)
- Region & 	getBodyRegion ()
- Block * 	getBody ()
- Optional< StringRef > 	getName ()
- void 	push_back (Operation *op)
}

{
mlir::FunctionType
- static FunctionType 	get (ArrayRef< Type > inputs, ArrayRef< Type > results, MLIRContext *context)
- unsigned 	getNumInputs () const
- Type 	getInput (unsigned i) const
- ArrayRef< Type > 	getInputs () const
- unsigned 	getNumResults () const
- Type 	getResult (unsigned i) const
- ArrayRef< Type > 	getResults () const
}

{
func::FuncOp
- static FuncOp create(Location location, StringRef name, FunctionType type, ArrayRef< NamedAttribute > attrs={})
- static FuncOp 	create (Location location, StringRef name, FunctionType type, ArrayRef< NamedAttribute > attrs, ArrayRef< NamedAttributeList > argAttrs)
- void 	eraseArgument (unsigned argIndex)
- void 	eraseArguments (ArrayRef< unsigned > argIndices)
- FunctionType 	getType ()
- void 	setType (FunctionType newType)
- FuncOp 	clone (BlockAndValueMapping &mapper)
- FuncOp 	clone ()
- Block * 	addEntryBlock ()
- Block * 	addBlock ()
}

/*
mlir::Block
*/

{
mlir::Block
- void 	clear ()
- Region * 	getParent () const
- Operation * 	getParentOp ()
- void 	insertBefore (Block *block)
- void 	insertAfter (Block *block)
- void 	erase ()
- BlockArgListType 	getArguments ()
- ValueTypeRange< BlockArgListType > 	getArgumentTypes ()
- args_iterator 	args_begin ()
- args_iterator 	args_end ()
- bool 	args_empty ()
- BlockArgument 	addArgument (Type type, Location loc)
- BlockArgument 	insertArgument (unsigned index, Type type, Location loc)
- void 	eraseArgument (unsigned index)
- unsigned 	getNumArguments ()
- BlockArgument 	getArgument (unsigned i)
- OpListType & 	getOperations ()
- void 	push_back (Operation *op)
- void 	push_front (Operation *op)
- bool 	hasNoPredecessors ()
- bool 	hasNoSuccessors ()
- unsigned 	getNumSuccessors ()
- Block * 	getSuccessor (unsigned i)
- SuccessorRange 	getSuccessors ()
- Block * 	splitBlock (Operation *splitBeforeOp)

template<typename OpT >
- iterator_range< op_iterator< OpT > > 	getOps ()
}

/*
mlir::Region
- Region (Operation *container)
- MLIRContext * 	getContext ()
- Location 	getLoc ()
- BlockListType & 	getBlocks ()
- void 	push_back (Block *block)
- void 	push_front (Block *block)
- Region * 	getParentRegion ()
- Operation * 	getParentOp ()
*/


MLIRContext
DialectRegistry
